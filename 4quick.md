**БЫСТРАЯ СОРТИРОВКА**

**Вставьте объявление **quick_sort в файл sort.h, чтобы она была видна, как и остальные функции сортировки. **Замените в sort.cpp вызов bubble_sort на вызов quick_sort** с нужными параметрами


15. Надо понять, почему алгоритм, как он запрограммирован в quick_sort.cpp, всегда заканчивает работу. Заметно, что функция quick_sort не вызывает рекурсивно себя, только если на входе левая и правая граница совпадают: `if(l==r)return;`. **Почему не бывает так**, что для некоторого N мы достигнем ситуации, когда расстояние между l и r равно 1, после чего снова вызовется quick_sort с расстоянием между l и r равным 1, и так далее до бесконечности:

16. Запустите полученную программу 6 раз, по 2 раза для каждого значения  и **заполните следующую таблицу (**изменяйте N в зависимости от производительности вашей машины, аналогично заданию 7**):**

<table>
  <tr>
   <td>
<strong>quick_sort</strong>
<p>
N \

   </td>
   <td>Время первого запуска, мс
   </td>
   <td>Время второго запуска, мс
   </td>
  </tr>
  <tr>
   <td>100000
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>200000
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>400000
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
</table>


17. Сделайте **вывод, как растет** время с ростом n?

18. Замените выражение `A[i] = ...rand()...`. на следующее: `A[i] = i;` и снова запустите программу для трех значений N из пункта 16. **Изменилась ли** зависимость времени от _N_? Посмотрите пункт 3 статьи из Википедии [https://ru.wikipedia.org/wiki/Быстрая_сортировка](https://ru.wikipedia.org/wiki/Быстрая_сортировка) и **объясните** поведение программы в этом случае.

**THE END**
